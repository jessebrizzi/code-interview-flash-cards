<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>CodeCards</title>
    <!-- PWA Configuration -->
    <link rel="manifest" href="/manifest.json">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="apple-mobile-web-app-title" content="FlashCards">
    <link rel="apple-touch-icon" href="imgs/180.png">
    <meta name="theme-color" content="#000000">
    <!-- Favicon -->
    <link rel="icon" href="imgs/icon.svg">
    <!-- Stylesheets -->
    <link rel="stylesheet" href="style.css">
    <link rel="stylesheet"
        href="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/styles/github-dark.min.css">
    <!-- Scripts -->
    <script src="https://cdn.jsdelivr.net/npm/marked/marked.min.js"></script>
    <script src="https://cdn.jsdelivr.net/gh/highlightjs/cdn-release@11.9.0/build/highlight.min.js"></script>
    <script>
        // Register Service Worker
        if ('serviceWorker' in navigator) {
            window.addEventListener('load', () => {
                navigator.serviceWorker.register('/sw.js')
                    .then(registration => {
                        console.log('ServiceWorker registration successful');
                    })
                    .catch(err => {
                        console.log('ServiceWorker registration failed: ', err);
                    });
            });
        }
    </script>
</head>

<body>
    <!-- Theme Toggle Button -->
    <div class="theme-toggle">
        <button id="theme-button" onclick="toggleTheme()">üåô</button>
    </div>

    <!-- Feedback Buttons -->
    <div class="feedback-buttons">
        <button class="feedback-button thumbs-down" onclick="handleFeedback(false)">üëé</button>
        <button class="flip-button" onclick="flipCard(document.getElementById('flashcard'))">FLIP</button>
        <button class="feedback-button thumbs-up" onclick="handleFeedback(true)">üëç</button>
    </div>

    <!-- Flashcard Container -->
    <div class="card-container">
        <div class="card" id="flashcard" onclick="flipCard(this)">
            <div class="card-inner">
                <div class="card-front">
                    <div id="front-content"></div>
                </div>
                <div class="card-back">
                    <div id="back-content"></div>
                    <div id="solution-content"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Swipe handling
        let touchStartX = 0, touchEndX = 0, isSwiping = false;
        const SWIPE_THRESHOLD = 100;

        const flashcard = document.getElementById('flashcard');

        flashcard.addEventListener('touchstart', (e) => {
            // Check if the touch started inside a code block
            const target = e.target;
            const isCodeBlock = target.closest('pre');
            if (isCodeBlock) {
                return; // Allow normal scrolling behavior in code blocks
            }

            touchStartX = e.touches[0].clientX;
            isSwiping = false;
        });

        flashcard.addEventListener('touchmove', (e) => {
            // If touch started in code block, don't handle swipe
            const target = e.target;
            const isCodeBlock = target.closest('pre');
            if (isCodeBlock) {
                return; // Allow normal scrolling behavior in code blocks
            }

            const deltaX = Math.abs(e.touches[0].clientX - touchStartX);
            if (deltaX > 10) {
                isSwiping = true;
                e.preventDefault();
            }
        });

        flashcard.addEventListener('touchend', (e) => {
            // If touch started in code block, don't handle swipe
            const target = e.target;
            const isCodeBlock = target.closest('pre');
            if (isCodeBlock) {
                return; // Allow normal scrolling behavior in code blocks
            }

            touchEndX = e.changedTouches[0].clientX;
            if (isSwiping) handleSwipe();
        });

        function handleSwipe() {
            const swipeDistance = touchEndX - touchStartX;
            if (Math.abs(swipeDistance) >= SWIPE_THRESHOLD) {
                const isSwipeRight = swipeDistance > 0;
                flashcard.classList.add(isSwipeRight ? 'swipe-right' : 'swipe-left');
                setTimeout(() => handleFeedback(isSwipeRight), 500);
            }
        }

        // Theme Toggle
        function toggleTheme() {
            document.body.classList.toggle('dark-mode');
            document.getElementById('theme-button').textContent =
                document.body.classList.contains('dark-mode') ? '‚òÄÔ∏è' : 'üåô';
        }

        // Card Flip
        function flipCard(card) {
            if (!isSwiping) card.classList.toggle('flipped');
        }

        // Feedback Handling
        function handleFeedback(isCorrect) {
            flashcard.classList.remove('swipe-left', 'swipe-right', 'flipped');
            loadCard();
        }

        // Card caching
        let nextCardData = null;
        let cards = [];

        // Pre-cache the next random card
        async function preCacheNextCard() {
            try {
                if (cards.length === 0) {
                    // get list of cards
                    const response = await fetch('card-list.txt');
                    cards = (await response.text()).trim().split('\n');
                }
                const randomCard = cards[Math.floor(Math.random() * cards.length)];

                const [front, back, solution] = await Promise.all([
                    fetch(`cards/${randomCard}/front.md`).then(r => r.text()),
                    fetch(`cards/${randomCard}/back.md`).then(r => r.text()),
                    fetch(`cards/${randomCard}/solution.py`).then(r => r.text())
                ]);

                nextCardData = {
                    front: front,
                    back: back,
                    solution: solution
                };
            } catch (error) {
                console.error('Error pre-caching next card:', error);
            }
        }

        async function loadCard() {
            try {
                document.getElementById('front-content').innerHTML = marked.parse(nextCardData.front);
                document.getElementById('back-content').innerHTML = marked.parse(nextCardData.back);
                document.getElementById('solution-content').innerHTML =
                    `<h2>Solution</h2><pre><code class="language-python">${nextCardData.solution}</code></pre>`;
                hljs.highlightAll();

                // Clear the current cached data
                const currentCardData = nextCardData;
                nextCardData = null;

                // Pre-cache the next card
                preCacheNextCard();
            } catch (error) {
                console.error('Error loading card:', error);
            }
        }

        // Initial Theme and Card Load
        if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
            document.body.classList.add('dark-mode');
            document.getElementById('theme-button').textContent = '‚òÄÔ∏è';
        }
        // Load first card after pre-caching it
        preCacheNextCard().then(() => loadCard());
    </script>
</body>

</html>